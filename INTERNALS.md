# A more in-depth analysis of what is done and why

This exercise is meant to be a boilerplate and as such it is important to describe a bit more in-depth how it works.
Besides of the [API](API.md) which is purely about I/O operations and interactions with the outside world, this document focuses on the design patterns that where used and tries to give a proper explanation for each.

Of course, as always, software architecture (and architecture in general) is a lot about opinions.
So what is written here is opinionated and subject to be discussed. Feel free to do so by submitting issue if you want to start one, I will happily give you answer !

##Â Table of contents

0. Global architecture
1. Technology stack : why CoffeeScript ?
2. The Routes
3. The Models
4. Authentication, JWT and friends
5. The Managers
6. The Controllers
7. The Handlers
8. Configuration
9. Deployment and miscellaneous

# Global architecture

First off, it is important to understand how the whole API is architectured.

# Technology stack : why CoffeeScript ?

A lot of questions, flame wars sometimes arise when we start talking about programming languages.
To avoid trolling about all this, let's put it simply: **there is no perfect programming language**.

It is of course up to the developer to choose which one fits best for the purpose.
However I have chosen for long time `CoffeeScript` for sensible reasons:

> It is a transpiler

One must admit that Javascript evolved quite a lot these past years, ECMAScript 2015 added a lot of new syntax sugar and features to the main language.

[TBC]

# The Routes

# The Models

# Authentication, JWT and friends

# The Managers

# The Controllers

# The Handlers

# Configuration

# Deployment and miscellaneous
